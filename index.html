<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>dreamseqs visuals</title>
    <style>
      html {
        margin: 0;
        padding: 0;
      }

      body {
        margin: 0;
      }

      canvas {
        display: block;
        width: 960px;
        height: 540px;
        background-color: #000000;
      }
    </style>

    <script id="vertex-shader" type="x-shader/x-vertex">
      #version 300 es

      in vec2 position;
      uniform uint currentTimeMs;
      flat out uint vCurrentTimeMs;

      void main() {
        vCurrentTimeMs = currentTimeMs;
        gl_Position = vec4(position, 0.0, 1.0);
      }
    </script>

    <script id="fragment-shader-01" type="x-shader/x-fragment">
      #version 300 es

      precision highp float;
      flat in uint vCurrentTimeMs;
      out vec4 outColor;

      const float PI = 3.14159265;

      // @see https://github.com/dmnsgn/glsl-rotate/blob/main/rotation-3d.glsl
      // @see https://wgld.org/d/glsl/g017.html
      vec3 rotate(vec3 position, float angleRadian, vec3 axis) {
        axis = normalize(axis);
        float s = sin(angleRadian);
        float c = cos(angleRadian);
        float oc = 1.0 - c;

        mat3 rotateMatrix = mat3(
          oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
          oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
          oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c
        );

        return rotateMatrix * position;
      }

      vec3 rotateXDegree(vec3 position, float angleDegree) {
        return rotate(position, radians(angleDegree), vec3(1.0, 0.0, 0.0));
      }

      vec3 rotateZDegree(vec3 position, float angleDegree) {
        return rotate(position, radians(angleDegree), vec3(0.0, 0.0, 1.0));
      }

      float distanceFunc(vec3 position) {
        return length(position) - 1.0;
      }

      void main() {
        vec2 fragmentPosition = (gl_FragCoord.xy - vec2(960.0, 540.0)) / vec2(960.0, 540.0);

        float progress = float(vCurrentTimeMs % uint(8000)) / 8000.0;

        vec3 cameraPosition = vec3(0.0, -3.0, 0.0);
        vec3 ray = normalize(vec3(
          cos(PI * (-fragmentPosition.x + 0.5)) * cos(PI * fragmentPosition.y * 0.5),
          sin(PI * (-fragmentPosition.x + 0.5)) * cos(PI * fragmentPosition.y * 0.5),
          sin(PI * fragmentPosition.y * 0.5)
        ));

        ray = rotateXDegree(ray, 360.0 * progress);

        float distance = 0.0;
        float rayLength = 0.0;
        vec3 rayPosition = cameraPosition;

        for (int i = 1; i < 16; i++) {
          distance = distanceFunc(rayPosition);
          rayLength = rayLength + distance;
          rayPosition = cameraPosition + ray * rayLength;
        }

        outColor = vec4(step(distance, 0.001), 0.0, 0.0, 1.0);
      }
    </script>

    <script src="./visual_base.js"></script>
    <script>
      window.addEventListener('load', () => {
        const vertexShaderSourceCode = document.getElementById("vertex-shader").text.trim();
        const fragmentShaderSourceCode = document.getElementById("fragment-shader-01").text.trim();
        const visual = new Visual();
        visual.setShaderSourceCode(vertexShaderSourceCode, fragmentShaderSourceCode);
        visual.run();
      });
    </script>
  </head>
  <body>
    <canvas class="canvas" id="canvas" width="1920" height="1080"></canvas>
  </body>
</html>
